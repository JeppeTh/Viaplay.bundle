import re, shutil
from lxml.etree import HTMLParser, parse, tostring
import StringIO

IPAD_UA = 'Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X; en-us) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B176 Safari/7534.48.3'

SAMSUNG_UA = 'Mozilla/5.0 (SmartHub; SMART-TV; U; Linux/SmartTV; Maple2012) AppleWebKit/534.7 (KHTML, like Gecko) SmartTV Safari/534.7'

BANDWIDTH_PATTERN = Regex('#EXT.*BANDWIDTH=([0-9]+)')

####################################################################################################
def MetadataObjectForURL(url):

    Login()

    # Request the URL
    item = MyJson(url)
    item = item['_embedded']['viaplay:blocks']
    item = item[0]['_embedded']['viaplay:product']
    item_type = item['type']

    try:
        thumb = item['content']['images']['landscape']['url']
    except:
        thumb = None

    air_date = item['system']['availability']['start']
    item     = item['content']
    try:
        duration = int(item['duration']['milliseconds'])
    except:
        duration = None
    thumb = None
    if 'boxart' in item['images']:
        thumb = item['images']['boxart']['url']
    if 'landscape' in item['images']:
        thumb   = item['images']['landscape']['url']

    if item_type == 'episode':
        if 'episodeNumber' in item['series']:
            index = int(item['series']['episodeNumber'])
        else:
            index = None
        return EpisodeObject(
            title    = unicode(item['title']),
            show     = unicode(item['series']['title']),
            summary  = unicode(item['synopsis']),
            duration = duration,
            thumb    = thumb,
            index    = index,
            season   = int(item['series']['season']['seasonNumber']),
            originally_available_at = Datetime.ParseDate(air_date).date()
            )
    else:
        return VideoClipObject(
            title    = unicode(item['title']),
            summary  = unicode(item['synopsis']),
            thumb    = thumb,
            duration = duration
            )

####################################################################################################
def MediaObjectsForURL(url):
    return [
      MediaObject(
                  parts = [PartObject(key=HTTPLiveStreamURL(Callback(PlayVideo, url = url, platform = Client.Platform)))],
                  audio_channels = 2
      )
    ]

def PlayVideo(url, platform):
    Login()

    item = MyJson(url)
    item = item['_embedded']['viaplay:blocks']
    item_type = item[0]['_embedded']['viaplay:product']['type']
    item = item[0]['_embedded']['viaplay:product']
    product = item['system']['productId']

    Log("JTDEBUG productId:%i" % product)

    try:
        url = GetStream(product)
        Log("JTDEBUG url:%s" % url)
        if len(url) == 0:
            raise Ex.MediaNotAvailable
    except:
        raise Ex.MediaNotAvailable
    
    if platform == ClientPlatform.iOS:
        return Redirect(url)
    else:
        original_playlist = HTTP.Request(url).content
        new_playlist      = RegeneratePlaylist(original_playlist.splitlines(), url[:url.rindex("/")])
        Log("JTDEBUG new_playlist:%s" % new_playlist)
        return new_playlist

def GetStream(product):
    site = Prefs['site'].lower()
    stream_url = "http://play.viaplay." + site + "/api/playlist/v1?deviceKey="+ GetDeviceKey(site) + "&productId=%s" % product
    # Some viaplay xml is broken, so parse it with a more lenient HTML parser instead
    data = HTTP.Request(stream_url).content
    parser = HTMLParser()
    tree = parse(StringIO.StringIO(data), parser)
    url = tree.xpath("/html/body/playlist/entries/entry/url")[0].text
    return url

######################################
# Plex is unable to handle relative playlist files and doesn't select the correct bandwidth
# so we are manually creating the playlist with the max bandwidth
######################################
def RegeneratePlaylist(playlist, url):
    max_bandwidth = 0
    max_bandwidth_meta = ""
    max_bandwidth_url = ""
    
    reading = False
    
    new_playlist = '#EXTM3U\n'
    for line in playlist:
        bandwidth = BANDWIDTH_PATTERN.search(line)
        if not bandwidth:
            if not reading:
                continue
            else:
                if not line.startswith('http'):
                    max_bandwidth_url = url + '/' + line
                else:
                    max_bandwidth_url = line
                reading = False
        else:
            current_bandwidth = int(bandwidth.group(1))
        
            if current_bandwidth > max_bandwidth:
                max_bandwidth = current_bandwidth
                max_bandwidth_meta = line
                reading = True
    

    new_playlist = new_playlist + max_bandwidth_meta + '\n'
    new_playlist = new_playlist + max_bandwidth_url + '\n'

    return new_playlist

####################################################################################################
def NormalizeURL(url):
    return url

def Login():
    site = Prefs['site'].lower()
    device_key = GetDeviceKey(site)
    api = "https://login.viaplay." + site + "/api"
    url = api + "/persistentLogin/v1?deviceKey=" + device_key + "&returnurl=http%3A%2F%2Fcontent.viaplay." + site + "%2F" + device_key
    try:
        loginPage = MyJson(url)
        loginResult = loginPage['success']
    except:
        loginResult = False
    if loginResult == False:
        email    = String.Quote(Prefs['username'])
        password = String.Quote(Prefs['password'])
        authUrl = api + "/login/v1?deviceKey=" + device_key + "&returnurl=http%3A%2F%2Fcontent.viaplay."+ site + "%2F" + device_key + "&username=" + email + "&password="+ password + "&persistent=true"
        loginPage  = MyJson(authUrl)
        if loginPage['success'] == False:
            raise Exception("Login Failed")

    if Prefs['ageVerification'] == True:
        agePage = MyJson(api + "/ageVerification/v1?deviceKey=" + device_key + "&returnurl=https%3A%2F%2Fcontent.viaplay." + site + "%2F" + device_key)
        if agePage['success'] == False:
            raise Exception("Age Verification Failed")

def MyJson(url):
    return JSON.ObjectFromURL(re.sub("{\\?dtg}", "", url))

def GetDeviceKey(site):
    # return "web-" + site
    return "androidnodrm-" + site

def OldGetStream(url):

    base_url = re.sub("(.*viaplay\\.[^/]+).*", "\\1", url)

    email    = String.Quote(Prefs['username'])
    password = String.Quote(Prefs['password'])
    authUrl  = "https://lhr2.ops.entriq.net/services/payment/paymentws.svc/Ajax/Loginbyget?request=%7B%22Email%22%3A%22" + email + "%22%2C%22Password%22%3A%22" + password + "%22%2C%22AccountId%22%3A%22viasat%22%2C%22Cookies%22%3A%22%22%7D"
    authPage  = JSON.ObjectFromURL(authUrl)
    if authPage['d']['IsSuccessful'] == False:
        raise Exception("Login Failed")

    myCookie  = "VCDataType=json;OPS=" + authPage['d']['Cookies']
    tokenUrl  = base_url + '/ahah/getCookieHashAjax'
    tokenData = HTTP.Request(tokenUrl, headers = {'User-Agent': IPAD_UA, 'X-Requested-With': 'XMLHttpRequest','Cookie':myCookie})
    myCookie  = myCookie + "; token=" + tokenData

    page = HTML.ElementFromURL(url)

    id = page.xpath("//div[@id='productSelect']")[0].get('data-product-id')
    url = base_url + '/ahah/videoData?id=' + id
    data = JSON.ObjectFromURL(url, headers = {'User-Agent': IPAD_UA, 'X-Requested-With': 'XMLHttpRequest','Cookie':myCookie})

    # [] is returned if the data isn't available
    if (isinstance(data, list)):
        Log('Unable to be source data')
        return None
    
    return data['source']
