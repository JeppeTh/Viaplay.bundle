import re, shutil, urllib
from lxml.etree import HTMLParser, parse, tostring
import StringIO

from viaplaylib import MyJson as MyJson
from viaplaylib import Login as Login

IPAD_UA = 'Mozilla/5.0 (iPad; CPU OS 5_1 like Mac OS X; en-us) AppleWebKit/534.46 (KHTML, like Gecko) Version/5.1 Mobile/9B176 Safari/7534.48.3'

SAMSUNG_UA = 'Mozilla/5.0 (SmartHub; SMART-TV; U; Linux/SmartTV; Maple2012) AppleWebKit/534.7 (KHTML, like Gecko) SmartTV Safari/534.7'

BANDWIDTH_PATTERN = Regex('#EXT.*BANDWIDTH=([0-9]+)')

####################################################################################################
def MetadataObjectForURL(url):

    # Request the URL
    try:
        item = MyJson(urllib.unquote(url))
    except:
        ## Perhaps login is required...
        Login()
        item = MyJson(urllib.unquote(url))

    item = item['_embedded']['viaplay:blocks']
    item = item[0]['_embedded']['viaplay:product']
    item_type = item['type']

    try:
        thumb = item['content']['images']['landscape']['url']
    except:
        thumb = None

    air_date = item['system']['availability']['start']
    item     = item['content']
    try:
        duration = int(item['duration']['milliseconds'])
    except:
        duration = None
    thumb = None
    if 'boxart' in item['images']:
        thumb = item['images']['boxart']['url']
    if 'landscape' in item['images']:
        thumb   = item['images']['landscape']['url']

    if item_type == 'episode':
        if 'episodeNumber' in item['series']:
            index = int(item['series']['episodeNumber'])
        else:
            index = None
        return EpisodeObject(
            title    = unicode(item['title']),
            show     = unicode(item['series']['title']),
            summary  = unicode(item['synopsis']),
            duration = duration,
            thumb    = thumb,
            index    = index,
            season   = int(item['series']['season']['seasonNumber']),
            originally_available_at = Datetime.ParseDate(air_date).date()
            )
    else:
        return VideoClipObject(
            title    = unicode(item['title']),
            summary  = unicode(item['synopsis']),
            thumb    = thumb,
            duration = duration
            )

####################################################################################################
def MediaObjectsForURL(url):
    # Seems some setups (chromecast?) causes url to be urlencoded...
    return [
      MediaObject(
                  parts = [PartObject(key=HTTPLiveStreamURL(Callback(PlayVideo, url = urllib.unquote(url), platform = Client.Platform)))],
                  audio_channels = 2,
                  optimized_for_streaming = True
      )
    ]

def PlayVideo(url, platform):
    Login()

    try:
        stream_url = []
        stream_url = GetStream(url)
        if len(stream_url) == 0:
            raise Ex.MediaNotAvailable
    except Exception as e:
        raise Ex.MediaNotAvailable
    
    if platform == ClientPlatform.iOS or Prefs['playerDecideBitRate']:
        Log("JTDEBUG : Assuming (iOS) manages necessary url params if necessary:%s" % stream_url)
        return Redirect(stream_url)
    else:
        return RegeneratePlaylist(stream_url)

def GetStream(url):

    item = MyJson(url)
    item = item['_embedded']['viaplay:blocks']
    item = item[0]['_embedded']['viaplay:product']

    stream = item['_links']['viaplay:stream']['href']
    stream = re.sub("(.+)({\\?deviceId.+userAgent})(.+)", "\\1?deviceId=deviceId&deviceName=deviceName&deviceType=deviceType&userAgent=userAgent\\3", stream)
    stream_item = MyJson(stream)
    if 'message' in stream_item and stream_item['message'] == "PG challenge" and Prefs['pin'] and Prefs['pin'] != "":
        stream_item = MyJson(stream + "&pgPin=" + Prefs['pin'])
    return stream_item['_links']['viaplay:playlist']['href']


######################################
# Plex is unable to handle relative playlist files and doesn't select the correct bandwidth
# so we are manually creating the playlist with the max bandwidth
######################################
def RegeneratePlaylist(stream_url):

    playlist = HTTP.Request(stream_url).content.splitlines()
    # Log("JTDEBUG : playlist:%s" % playlist)

    max_bandwidth = 0
    max_bandwidth_meta = ""
    max_bandwidth_url = ""
    new_playlist = ""
    
    reading = False

    url_params = re.sub(".+(\.m3u8.*)","\\1", stream_url)
    url_prefix = stream_url[:stream_url.rindex("/")]
    
    for line in playlist:
        bandwidth = BANDWIDTH_PATTERN.search(line)
        if not bandwidth:
            if '#' in line:
                new_playlist = new_playlist + line + '\n'
            elif not reading:
                continue
            else:
                if not line.startswith('http'):
                    max_bandwidth_url = url_prefix + '/' + line
                else:
                    max_bandwidth_url = line
                reading = False
        else:
            current_bandwidth = int(bandwidth.group(1))
        
            if current_bandwidth > max_bandwidth:
                max_bandwidth = current_bandwidth
                max_bandwidth_meta = line
                reading = True
    
    if max_bandwidth_url.endswith(".m3u8"):
        # Add url params
        max_bandwidth_url = re.sub("\.m3u8", url_params, max_bandwidth_url)
    new_playlist = new_playlist + max_bandwidth_meta + '\n'
    new_playlist = new_playlist + max_bandwidth_url + '\n'

    Log("JTDEBUG : new_playlist:%s" % new_playlist)

    if len(url_params) > 5 and Prefs['experimental']:
        return ReadM3u8(url_prefix, url_params, max_bandwidth_url)
    return new_playlist

######################################
def ReadM3u8(url_prefix, url_params, m3u8_url):

    # Experimental...

    url_params = re.sub("^\.m3u8", "", url_params)

    m3u8_content = HTTP.Request(m3u8_url).content.splitlines()

    new_content = ""
    
    for line in m3u8_content:
        if ".ts" in line:
            if not line.startswith('http'):
                line = url_prefix + '/' + line
            line = re.sub("\.ts.*", ".ts%s" % url_params, line)
        new_content = new_content + line + '\n'

    # Log("JTDEBUG : new_content:%s" % new_content)

    return new_content

####################################################################################################
def NormalizeURL(url):
    return url
